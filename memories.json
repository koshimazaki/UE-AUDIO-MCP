{
  "memories": [
    {
      "id": "mem_1770385162176_1q1l3g5xr",
      "content": "## UE5-WWISE Project - Complete Exploration Summary\n\n### Project Overview\n- **Name**: UE Audio MCP (Unreal Engine Audio MCP Server)\n- **Creator**: Koshi (creator of SIDKIT, VibeComfy MCP)\n- **Status**: Early development, building in public\n- **Phase**: Research and planning phase (no implementation code yet)\n- **Goal**: Build complete game audio systems from natural language descriptions using MCP protocol\n\n### Architecture\nThe project applies SIDKIT's agent-generated audio systems philosophy to game engines. Three-layer architecture:\n1. **Blueprint** (WHEN) - Game event detection, parameter setting - UE5 Remote Control API\n2. **MetaSounds** (WHAT) - Procedural DSP synthesis, audio generation - Builder API via plugin\n3. **Wwise** (HOW) - Mixing, buses, spatialization, RTPC - WAAPI (WebSocket :8080)\n\n### File Tree Structure\n```\n/UE5-WWISE/\n├── README.md (11k) - Project vision, architecture, tool groups\n├── ROADMAP.md (9.5k) - 5-phase development plan with dependencies\n├── .gitignore - Standard Python, Node, UE5 ignores\n├── research/ - Research documentation (80KB total)\n│   ├── research_waapi_mcp_server.md (69KB) - Complete WAAPI API reference, 87 functions\n│   └── research_metasounds_game_audio.md (11KB) - MetaSounds patterns and Builder API\n├── src/ - (Directory structure only, no files yet)\n│   ├── tools/\n│   │   ├── wwise/\n│   │   ├── metasounds/\n│   │   └── blueprints/\n│   ├── knowledge/\n│   ├── protocol/\n│   └── systems/\n├── templates/ - (Empty directory)\n├── tests/ - (Empty directory)\n├── .claude/ - (Claude workspace, empty)\n├── logs/ - Application logs (LMStudio health checks)\n└── memories.json - (Empty memories file)\n```\n\n### Git History\n- Commit 5c984e6: \"Add research files, .gitignore, and project structure\" (latest)\n- Commit 33ba52d: \"Initial project setup: UE Audio MCP\"\n- Branch: master (up to date with origin)\n- Untracked: memories.json\n\n### Key MCP Servers Referenced\n1. **SIDKIT** - Hardware synthesis agent, generates C++ firmware for Teensy ARM\n2. **VibeComfy MCP** - ComfyUI nodes (8,400+ nodes) via MCP\n3. **Blender MCP** - Controls Blender via MCP (16.9k stars reference)\n4. **unreal-mcp** - Controls UE5 editor (chongdashu) - no audio support\n\n### Research Documentation Summary\n\n#### WAAPI (Wwise Authoring API)\n- **Protocol**: WAMP (WebSocket) on ws://127.0.0.1:8080/waapi or HTTP POST on :8090\n- **Status**: 87+ API functions, fully documented\n- **Libraries**: waapi-client (official Python), pywwise (Pythonic wrapper)\n- **Key limitation**: Wwise Authoring App MUST be running (no true headless mode)\n- **Functions**:\n  - Object CRUD: create, delete, get, move, copy, setProperty, setReference\n  - Audio import with multiple operation modes (createNew, useExisting, replaceExisting)\n  - Switch containers and state groups with assignments\n  - RTPC curve management\n  - Attenuation curve configuration\n  - SoundBank generation\n  - Transport control for previewing\n  - WAQL (Wwise Authoring Query Language) for object search\n\n#### MetaSounds & Builder API\n- **Asset types**: Source (playable), Patch (reusable subgraph), Preset (parameter overrides)\n- **Graph model**: Flow graph with sample-accurate timing, signal-by-reference\n- **Data types**: Audio, Trigger, Float, Int32, Bool, Time, String, UObject, Enum, WaveAsset, Arrays\n- **80+ nodes**: Generators, Wave Players, Envelopes, Filters, Delays, Dynamics, Triggers, Arrays, Math, Mix, Spatialization, Music, Random\n- **Builder API**: Experimental (UE 5.4+), enables runtime graph creation\n- **Key interfaces**: UE.Source.OneShot, UE.Attenuation, UE.Spatialization\n- **Six game audio patterns**: Gunshots, Footsteps, Ambient, Spatial (Panning), UI Sounds, Weather/State Switches\n\n#### Audio Link Bridge\n- **Purpose**: Enables MetaSounds + Wwise coexistence (UE 5.1+)\n- **Direction**: One-way only (MetaSounds → Wwise via Audio Input Events)\n- **Use**: Procedural audio synthesis through Wwise mixing pipeline\n\n### A2HW Protocol (Agent-to-Hardware)\n- **Purpose**: Shared language between SIDKIT and UE Audio MCP\n- **Concept**: One synthesis description maps to multiple targets:\n  - SIDKIT: SysEx → Teensy ARM (hardware synth)\n  - Browser: JS → ModuleRunner (web preview)\n  - MetaSounds: Builder API → UE5 (game engine)\n  - Wwise: WAAPI → mixing pipeline (middleware)\n- **Status**: Planned Phase 5 (spec and standardization)\n\n### Development Roadmap (5 Phases)\n1. **Phase 1 (Weekend)**: Wwise MCP standalone via WAAPI\n2. **Phase 2 (1-2 days)**: MetaSounds knowledge base (node database)\n3. **Phase 3 (1 week)**: UE5 audio plugin (Builder API bridge)\n4. **Phase 4 (1-2 weeks)**: Systems orchestration layer\n5. **Phase 5 (Ongoing)**: A2HW protocol specification and standardization\n\n### Tech Stack\n- **MCP Server**: Python (FastMCP)\n- **Wwise Bridge**: waapi-client (official Audiokinetic Python library)\n- **UE5 Bridge**: Custom C++ plugin with TCP server (Builder API + Remote Control)\n- **Knowledge Base**: JSON node databases\n- **Templates**: Parameterized patterns for common game audio systems\n\n### Higher-Level Tool Groups\n**Systems Layer** (Phase 4 - orchestrates all three):\n- build_system - Generic audio system from text description\n- build_footsteps - Complete surface-reactive footstep system\n- build_weapon_audio - Gunshot + shell + tail + distance\n- build_ambient - Zone-based ambient with layers\n- build_ui_audio - Procedural UI sound set\n- build_weather - State-driven weather audio system\n\n### Important Notes\n- **No existing Wwise MCP server** - This would be first-of-its-kind\n- **No existing MetaSounds MCP integration** - Gap confirmed\n- **SIDKIT inspiration**: Same 3-layer architecture philosophy applied to game engines\n- **Lyra Starter Game**: Reference implementation for MetaSounds patterns\n- **Builder API experimental**: May change between UE versions\n- **AudioLink setup**: MetaSounds side requires custom patches, UE5 side requires Wwise Audio Input Events\n\n### Current Project State\n- Research phase complete (80KB+ of detailed documentation)\n- Directory structure created but empty (src/, templates/, tests/, .claude/)\n- No implementation code yet\n- Ready for Phase 1 (Wwise MCP) development\n- All dependencies and APIs researched and documented\n",
      "type": "config",
      "tags": [
        "config",
        "python",
        "api",
        "database",
        "UE5-WWISE",
        "MCP-servers",
        "audio-systems",
        "game-audio",
        "architecture",
        "WAAPI",
        "MetaSounds",
        "project-structure"
      ],
      "timestamp": "2026-02-06T13:39:22.175Z",
      "context": "Exploration of UE5-WWISE project at /Users/radek/Documents/GIthub/UE5-WWISE",
      "accessCount": 0,
      "lastAccessed": "2026-02-06T13:39:22.175Z",
      "lastVerified": "2026-02-06T13:39:22.175Z",
      "status": "fresh"
    },
    {
      "id": "mem_1770385395012_sc5fsab52",
      "content": "UE5-WWISE project setup complete. Created .claude/CLAUDE.md (main prompt), 3 slash commands (/ue-agent, /wwise-agent, /build-system), settings.json, and auto memory. Project builds first MCP server for game audio — Wwise + MetaSounds + Blueprint pipeline from natural language. Phase 1 (Wwise MCP) ready to start coding with waapi-client Python library.",
      "type": "config",
      "tags": [
        "config",
        "python",
        "ue5-wwise",
        "project-setup",
        "mcp",
        "game-audio"
      ],
      "timestamp": "2026-02-06T13:43:15.012Z",
      "context": "Initial project agent setup for UE Audio MCP",
      "accessCount": 0,
      "lastAccessed": "2026-02-06T13:43:15.012Z",
      "lastVerified": "2026-02-06T13:43:15.012Z",
      "status": "fresh"
    },
    {
      "id": "mem_1770385564956_5k72eql7d",
      "content": "## SIDKIT Agent Architecture - Complete Reference\n\n### Project Overview\nSIDKIT Agent is a Rust-based LLM-powered C++ code generation system for the SIDKIT synthesizer platform (Teensy 4.1). It features:\n- Agentic tool-use loop with Claude API\n- Autonomous GCC compilation & error fixing\n- Teensy hardware flashing via USB\n- SQLite-based learning (error patterns, build history)\n- Semantic knowledge base search\n- Dual-mode operation: Full agent server vs. LLM-agnostic tool server\n\n### Tech Stack\n- **Language**: Rust 2021 edition\n- **LLM**: Claude API (Haiku/Sonnet/Opus models)\n- **Web Framework**: Axum 0.7 (async HTTP)\n- **Compilation**: arm-none-eabi-gcc wrapper\n- **Hardware**: teensy_loader_cli for flashing\n- **Storage**: SQLite with rusqlite\n- **Serialization**: serde/serde_json\n\n### File Structure\n```\nsidkit-agent/\n├── src/\n│   ├── main.rs                  # CLI entry (Serve/Tools/Build/Flash/Devices)\n│   ├── agent.rs                 # Core agent + ToolExecutor impl\n│   ├── llm/\n│   │   ├── mod.rs              # Exports\n│   │   ├── claude.rs           # Agentic loop, API calls\n│   │   ├── tools.rs            # Tool defs + knowledge types\n│   │   └── prompts.rs          # System prompts, templates\n│   ├── server/\n│   │   ├── mod.rs              # Exports\n│   │   ├── http.rs             # Agentic server (Axum)\n│   │   └── tools.rs            # Pure tool server (no LLM)\n│   ├── knowledge/\n│   │   ├── mod.rs              # SDK reference constants\n│   │   └── base.rs             # Semantic search, JSON loading\n│   ├── storage/\n│   │   ├── mod.rs              # Exports\n│   │   └── db.rs               # SQLite wrapper\n│   ├── toolchain/\n│   │   ├── mod.rs              # Exports\n│   │   ├── gcc.rs              # arm-none-eabi-gcc wrapper\n│   │   └── errors.rs           # Error parsing\n│   └── flasher/\n│       ├── mod.rs              # Exports\n│       ├── teensy.rs           # USB bootloader\n│       └── intel_hex.rs        # HEX file parsing\n├── knowledge/                   # JSON knowledge base\n│   ├── games.json\n│   ├── patches.json\n│   ├── synthesis.json\n│   └── inspirations.json\n├── templates/                   # (empty, templates in code)\n├── migrations/                  # (empty)\n├── scripts/\n│   └── create-macos-app.sh     # macOS menubar build\n├── Cargo.toml\n└── README.md\n```\n\n### Core Components\n\n#### 1. Agent Loop (src/agent.rs)\n- **SidkitAgent**: Main agent orchestrating tools\n- **BuildSession**: Tracks state during build\n- **ToolExecutor trait**: Executes tools for LLM\n- Tools: generate_code, compile, search_knowledge, read_sdk, search_patterns, flash, report_status, complete\n\n#### 2. LLM Client (src/llm/claude.rs)\n- **AgenticClient**: Manages API calls & tool loops\n- **Models**: Haiku, Sonnet, Opus with model IDs\n- **Tool loop**: Call → Get blocks → Execute → Feedback → Repeat\n- System prompt includes SDK reference\n- Max iterations: 10 (configurable)\n\n#### 3. Tool Definitions (src/llm/tools.rs)\n- 8 tools exposed to Claude\n- **Knowledge types**: 19 categories (patches, templates, sdk, synthesis, games, shaders, algorithms, chips, engines, design, inspirations, guides, schemas, patterns, effects, ui-ux, platform, webui, faq)\n- **Metadata**: difficulty, cpu_cost, dependencies, voice_count, author, source\n- Search: embedding-based (if available) + keyword + tag matching\n\n#### 4. HTTP Servers (src/server/)\n\n**Full Agent Server** (/serve):\n- /build (POST) - Start agentic build\n- /build/:id/status - Get status\n- /build/:id/events - Stream events\n- /build/:id/download - Get hex\n- /flash, /devices, /history\n\n**Pure Tool Server** (/tools):\n- /compile (POST) - GCC compile only\n- /flash (POST) - Flash hex\n- /pio/build, /pio/upload - PlatformIO\n- /search (GET) - Knowledge API proxy\n- /doc/:id (GET) - Fetch doc\n- /devices - List Teensy\n\n#### 5. Knowledge Base (src/knowledge/)\n- **SDK constants**: IModule, Display (Adafruit GFX), Audio (48kHz), MIDI, Events, Examples, Templates\n- **File format**: MCP-server JSON with title, category, description, tags, content\n- **Search**: Loads from ~/.sidkit-agent/knowledge/ (or custom dir)\n- Categories indexed by hash maps\n\n#### 6. Storage (src/storage/db.rs)\n- **Location**: ~/.sidkit-agent/sidkit.db (SQLite)\n- **Tables**: \n  - builds (id, prompt, module_type, attempts, final_code, success, duration_ms, created_at)\n  - error_patterns (error_signature, successful_fix, fix_explanation, occurrences, successes)\n- **Auto-learning**: Patterns stored after successful fixes\n\n#### 7. Toolchain (src/toolchain/gcc.rs)\n- **Compiler**: arm-none-eabi-gcc (Cortex-M7)\n- **Flags**: -std=c++17, -O2, cortex-m7, thumb, hard float\n- **Error parsing**: Regex-based GCC output parsing\n- **Output**: firmware.hex (linker step handled externally)\n- **Includes**: SIDKIT_FIRMWARE_PATH env var for SDK headers\n\n#### 8. Flasher (src/flasher/teensy.rs)\n- **Protocol**: teensy_loader_cli binary\n- **USB IDs**: 0x16C0 vendor, 0x0478 bootloader, 0x0476 running\n- **Method**: Looks for teensy_loader_cli in PATH, Homebrew, Teensyduino\n- **Input**: .hex file path\n- **Features**: List devices, detect bootloader, reboot to bootloader\n\n### Agent Execution Flow\n1. User calls `build` with prompt\n2. Agent creates BuildSession\n3. LLM loop (0-10 iterations):\n   - Send prompt + SDK + tools to Claude\n   - Claude picks tool(s) to call\n   - Agent executes tool (generate_code → write file → compile → parse errors)\n   - Feed results back to Claude\n   - Handle special tools: generate_code, compile, complete (signal finish)\n4. Store result: SQLite build record + error patterns learned\n5. Return BuildResult::Success or Failed\n\n### System Prompts & Templates\n**Three module types**:\n- Game (SlotType::ADVANCED, 25 CPU bits, 0 voices)\n- Synth (SlotType::SYNTH, 10 CPU bits, 4 voices, MIDI)\n- Sequencer (SlotType::SEQUENCER, 5 CPU bits, pattern trigger)\n\nTemplates include:\n- Full class structure with virtual methods\n- Example parameter handling\n- Display/MIDI/event handling skeletons\n\n### Knowledge Base Structure\n**Format**: JSON array of entries:\n```json\n{\n  \"id\": \"game-space-shooter\",\n  \"category\": \"games\",\n  \"title\": \"Space Shooter\",\n  \"description\": \"...\",\n  \"content\": \"// C++ code ...\",\n  \"tags\": [\"game\", \"shooter\"],\n  \"metadata\": {\"difficulty\": \"intermediate\", \"cpu_cost\": \"low\"}\n}\n```\n\n### CLI Commands\n```bash\nsidkit-agent serve --port 3001              # Full agentic server\nsidkit-agent tools --port 3002              # Tool server only\nsidkit-agent build \"prompt\" --model haiku   # Agentic CLI build\nsidkit-agent flash firmware.hex             # Flash hex directly\nsidkit-agent devices                        # List Teensy devices\nsidkit-agent history --limit 10             # Build history\nsidkit-agent models                         # Show available models\n```\n\n### Environment Variables\n- ANTHROPIC_API_KEY - Claude API auth\n- SIDKIT_FIRMWARE_PATH - Path to firmware SDK\n- RUST_LOG - Logging level\n\n### Key Design Patterns\n1. **Async throughout**: tokio for concurrency\n2. **Error learning**: Auto-stores fixes in DB\n3. **Semantic search**: Embedding + keyword fallback\n4. **Streaming events**: AgentEvent enum for UI\n5. **Dual servers**: Flexible deployment (agent-only or tool-only)",
      "type": "config",
      "tags": [
        "config",
        "rust",
        "c++",
        "api",
        "deployment",
        "sidkit",
        "architecture",
        "llm",
        "agent",
        "reference"
      ],
      "timestamp": "2026-02-06T13:46:04.956Z",
      "accessCount": 0,
      "lastAccessed": "2026-02-06T13:46:04.956Z",
      "lastVerified": "2026-02-06T13:46:04.956Z",
      "status": "fresh"
    }
  ],
  "lastUpdated": "2026-02-06T13:46:04.956Z"
}